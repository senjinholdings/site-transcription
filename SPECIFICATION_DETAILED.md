# Site Transcription 詳細仕様書

フルページWebサイトキャプチャ＆OCR文字起こしツール - 完全版

---

## 1. システム概要

### 1.1 目的
指定したURLのWebページを完全なフルページ画像としてキャプチャし、画像内のすべてのテキスト（HTMLテキスト＋画像内テキスト）をAIで抽出・整形して返却する。

### 1.2 本番環境
- **URL**: https://site-transcription-592499304231.asia-northeast1.run.app
- **ホスティング**: Google Cloud Run (asia-northeast1)
- **メモリ**: 2GB
- **タイムアウト**: 300秒

### 1.3 技術スタック

| レイヤー | 技術 | バージョン | 用途 |
|----------|------|------------|------|
| ランタイム | Node.js | 22.x | サーバー実行環境 |
| Webフレームワーク | Express.js | 4.18.x | HTTPサーバー |
| ブラウザ自動化 | Playwright | 1.52.0 | ヘッドレスブラウザ制御 |
| ボット検出回避 | playwright-extra + puppeteer-extra-plugin-stealth | 4.3.6 / 2.11.2 | 自動化検出バイパス |
| 画像処理 | Sharp | 0.34.x | 画像合成・圧縮・リサイズ |
| OCR | Google Gemini Vision API | - | 画像からテキスト抽出 |
| ストレージ | Google Cloud Storage | 7.18.x | 画像永続化 |

---

## 2. 処理フロー全体像

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              ユーザーリクエスト                               │
│                         POST /api/capture { url }                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1: ジョブ生成                                                           │
│ - jobId = タイムスタンプ(36進数) + ランダム文字列                              │
│ - 即座に { jobId } を返却（非同期処理開始）                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 2: ブラウザ起動 [progress: 5%]                                          │
│ - Chromiumをヘッドレスモードで起動                                            │
│ - Stealth Pluginでボット検出回避                                             │
│ - サンドボックス無効化（Cloud Run対応）                                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3: ブラウザコンテキスト作成                                              │
│ - viewport: 1280x800px                                                      │
│ - deviceScaleFactor: 2（Retina相当、実質2560x1600px）                        │
│ - userAgent: Chrome 120                                                     │
│ - Referer: https://www.google.com/（広告LP対策）                             │
│ - Accept-Language: ja-JP                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4: ページ読み込み [progress: 10%]                                       │
│ - page.goto(url, { waitUntil: 'load', timeout: 120000 })                    │
│ - 追加待機: 5000ms（JavaScript実行完了待ち）                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 5: 遅延読み込みコンテンツの強制読み込み                                   │
│ 5-1. 画像の遅延読み込み対応                                                   │
│      - img[data-src] → src属性にコピー                                       │
│      - img[data-lazy-src] → src属性にコピー                                  │
│                                                                             │
│ 5-2. 動画の再生開始（GIF風MP4対応）                                           │
│      - 全video要素を取得                                                     │
│      - muted = true を設定（自動再生ポリシー対策）                             │
│      - video.play() を実行                                                  │
│      - readyState >= 2 (HAVE_CURRENT_DATA) まで待機                         │
│      - タイムアウト: 3000ms                                                  │
│      - 追加待機: 500ms（フレーム描画待ち）                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 6: スクロールによる遅延コンテンツ読み込み                                 │
│ - 30回ループ:                                                               │
│   - window.scrollBy(0, window.innerHeight)                                  │
│   - 200ms待機                                                               │
│ - window.scrollTo(0, 0) でトップに戻る                                       │
│ - 1000ms待機                                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 7: 固定要素のフリーズ                                                   │
│                                                                             │
│ 目的: position: fixed/sticky の要素がスクロール時に                          │
│       重複表示されるのを防止                                                  │
│                                                                             │
│ 処理内容:                                                                    │
│ - 全DOM要素をスキャン                                                        │
│ - position: fixed の要素:                                                   │
│   - 現在の表示位置を計算 (getBoundingClientRect)                             │
│   - position: absolute に変換                                               │
│   - top/left を絶対座標で固定                                                │
│   - width/height を固定                                                     │
│                                                                             │
│ - position: sticky の要素:                                                  │
│   - position: relative に変換                                               │
│   - top/bottom を auto に設定                                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 8: セグメントキャプチャ [progress: 10-50%]                               │
│                                                                             │
│ 方式: ページをviewport高さ単位で分割キャプチャし、後で合成                      │
│                                                                             │
│ 計算:                                                                        │
│ - totalHeight = document.documentElement.scrollHeight                       │
│ - viewportHeight = window.innerHeight (800px)                               │
│ - numSegments = Math.ceil(totalHeight / viewportHeight)                     │
│                                                                             │
│ 各セグメントの処理:                                                          │
│ - スクロール位置を計算                                                        │
│   - 通常: i * viewportHeight                                                │
│   - 最後: totalHeight - viewportHeight（端から取得）                         │
│ - window.scrollTo(0, scrollY)                                               │
│ - 100ms待機                                                                 │
│ - page.screenshot({ fullPage: false, type: 'png' })                         │
│                                                                             │
│ 出力: Buffer[] (PNGセグメント配列)                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 9: 画像合成 [progress: 50%]                                             │
│                                                                             │
│ Sharp を使用してセグメントを1枚に合成                                         │
│                                                                             │
│ 処理:                                                                        │
│ 1. 白背景のキャンバスを作成                                                   │
│    - width: viewportWidth * deviceScaleFactor (2560px)                      │
│    - height: totalHeight * deviceScaleFactor                                │
│    - background: #FFFFFF                                                    │
│                                                                             │
│ 2. 各セグメントを配置                                                         │
│    - 通常セグメント: top = i * segmentImageHeight                            │
│    - 最終セグメント: top = totalImageHeight - segmentImageHeight             │
│                                                                             │
│ 3. PNG形式で出力                                                             │
│                                                                             │
│ 出力: Buffer (フルページPNG画像)                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 10: Cloud Storage アップロード                                          │
│                                                                             │
│ バケット: site-transcription-captures                                        │
│                                                                             │
│ 画像最適化:                                                                  │
│ 1. 高さチェック                                                              │
│    - maxHeight: 16000px（JPEG形式の制限対策）                                │
│    - 超過時は自動リサイズ                                                     │
│                                                                             │
│ 2. JPEG変換・圧縮                                                            │
│    - quality: 85                                                            │
│    - PNG → JPEG で約70-80%サイズ削減                                         │
│                                                                             │
│ 3. アップロード                                                              │
│    - ファイル名: {jobId}.jpg                                                 │
│    - Content-Type: image/jpeg                                               │
│                                                                             │
│ 出力: 圧縮後のBuffer（OCR処理に使用）                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 11: ブラウザ終了                                                        │
│ - context.close()                                                           │
│ - browser.close()                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 12: OCR処理開始 [progress: 55%]                                         │
│                                                                             │
│ 使用AI: Google Gemini Vision API                                            │
│ モデル: gemini-2.0-flash（環境変数で変更可能）                                │
│ APIキー: GEMINI_API_KEY 環境変数                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 13: OCR用画像分割                                                       │
│                                                                             │
│ 目的: 長いページを分割して並列処理 & API制限対策                               │
│                                                                             │
│ 分割ルール:                                                                  │
│ - maxHeight: 4000px                                                         │
│ - 画像高さ <= 4000px → 分割なし                                              │
│ - 画像高さ > 4000px → 4000px単位で水平分割                                   │
│                                                                             │
│ 処理:                                                                        │
│ - numChunks = Math.ceil(height / 4000)                                      │
│ - 各チャンク: sharp.extract({ left: 0, top, width, height })                 │
│                                                                             │
│ 出力: Buffer[] (PNGチャンク配列)                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 14: Gemini Vision APIでテキスト抽出 [progress: 55-85%]                   │
│                                                                             │
│ 処理方式: 並列処理 (Promise.all)                                              │
│                                                                             │
│ 各チャンクに対して:                                                           │
│ ─────────────────────────────────────────────────────────────────────────── │
│ │ API呼び出し                                                               │
│ │                                                                           │
│ │ エンドポイント: Gemini generateContent API                                 │
│ │ モデル: gemini-2.0-flash                                                  │
│ │                                                                           │
│ │ リクエスト:                                                                │
│ │ {                                                                         │
│ │   contents: [{                                                            │
│ │     role: "user",                                                         │
│ │     parts: [                                                              │
│ │       { inlineData: { mimeType: "image/png", data: <base64> } },          │
│ │       { text: <プロンプト> }                                               │
│ │     ]                                                                     │
│ │   }],                                                                     │
│ │   generationConfig: {                                                     │
│ │     temperature: 0.1,        // 低温で正確性重視                           │
│ │     maxOutputTokens: 8192                                                 │
│ │   }                                                                       │
│ │ }                                                                         │
│ ─────────────────────────────────────────────────────────────────────────── │
│                                                                             │
│ 【テキスト抽出プロンプト（実際のプロンプト全文）】                               │
│ ═══════════════════════════════════════════════════════════════════════════ │
│                                                                             │
│ このスクリーンショットに表示されているすべてのテキストを抽出してください。        │
│                                                                             │
│ ## 重要: 以下のテキストもすべて抽出すること                                    │
│ - バナー画像・広告画像の中に書かれているテキスト                                │
│ - ロゴ画像の中のテキスト                                                      │
│ - インフォグラフィック・図解の中のテキスト                                      │
│ - 写真に重ねて表示されているテキスト                                           │
│ - ボタン・アイコンの中のテキスト                                               │
│ - 装飾的なキャッチコピー・見出し                                               │
│                                                                             │
│ ## 要件:                                                                     │
│ - 画面に見えているテキストは、HTMLテキストでも画像内テキストでも、              │
│   すべて抽出する                                                              │
│ - テキストの読み順（上から下、左から右）を維持する                              │
│ - 段落やセクションの区切りは空行で表現する                                      │
│ - 表がある場合は、セル内のテキストを行ごとに抽出する                            │
│ - 抽出したテキストのみを出力し、説明や前置きは不要                              │
│ - テキストが存在しない場合は、何も出力せず空のまま返す                          │
│                                                                             │
│ 出力形式: プレーンテキストのみ（テキストがなければ空）                          │
│                                                                             │
│ ═══════════════════════════════════════════════════════════════════════════ │
│                                                                             │
│ リトライ機構:                                                                │
│ - 最大リトライ: 3回                                                          │
│ - リトライ対象: 503, overloaded, UNAVAILABLE, 429                           │
│ - 遅延: 2秒 × (リトライ回数 + 1)                                             │
│                                                                             │
│ 「テキストがない」系応答のフィルタリング:                                       │
│ - 「この画像にはテキストが含まれていません」→ 空文字に変換                      │
│ - 「テキストは.*ありません」→ 空文字に変換                                     │
│ - 「テキストが存在しません」→ 空文字に変換                                     │
│ - 「なし」→ 空文字に変換                                                      │
│                                                                             │
│ 出力: string[] (各チャンクの抽出テキスト)                                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 15: チャンクテキスト結合                                                 │
│                                                                             │
│ 処理: allTexts.join('\n\n')                                                  │
│ - 各チャンクのテキストを空行2つで結合                                          │
│                                                                             │
│ 出力: string (結合された生テキスト)                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 16: ルールベース前処理 (preCleanOcr)                                     │
│                                                                             │
│ 目的: AIを使わずに確実に修正できるパターンを先に処理                            │
│                                                                             │
│ 処理内容:                                                                    │
│ ─────────────────────────────────────────────────────────────────────────── │
│ 1. よくあるOCR誤字を修正                                                      │
│    - 「休舌」→「体重」                                                        │
│    - 「內臟」「内臟」→「内臓」                                                 │
│    - 「㎡」→「㎠」                                                            │
│                                                                             │
│ 2. 数値の断片化を修正                                                         │
│    - 「100\nkg」→「100kg」                                                   │
│    - 「1,000\n円」→「1,000円」                                               │
│    - 「50\n%」→「50%」                                                       │
│    - パターン: /(\d+\.?\d*)\n(kg|円|%|cm|㎠)/g                               │
│                                                                             │
│ 3. 連続空行を制限                                                             │
│    - 4行以上の空行 → 3行に制限                                                │
│    - パターン: /\n{4,}/g → '\n\n\n'                                          │
│                                                                             │
│ 4. 行頭・行末の不要スペースを削除                                              │
│    - 各行を trim()                                                           │
│ ─────────────────────────────────────────────────────────────────────────── │
│                                                                             │
│ 出力: string (前処理済みテキスト)                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 17: AI後処理（改行整形） [progress: 90%]                                 │
│                                                                             │
│ 使用AI: Google Gemini Vision API                                            │
│ モデル: gemini-2.0-flash                                                    │
│                                                                             │
│ API設定:                                                                     │
│ {                                                                           │
│   generationConfig: {                                                       │
│     temperature: 0.2,        // 前処理より少し高め（整形の柔軟性）             │
│     maxOutputTokens: 8192                                                   │
│   }                                                                         │
│ }                                                                           │
│                                                                             │
│ 【改行整形プロンプト（実際のプロンプト全文）】                                   │
│ ═══════════════════════════════════════════════════════════════════════════ │
│                                                                             │
│ 以下のOCR抽出テキストの改行を整理してください。                                 │
│                                                                             │
│ ## 重要な制約:                                                               │
│ - **テキストの順序は絶対に変更しない**（上から下の順序を厳守）                   │
│ - **内容の削除・省略・要約は絶対禁止**                                         │
│ - **構造化・再編成は禁止**                                                    │
│                                                                             │
│ ## 必須の処理:                                                               │
│ 1. **文章の結合**: 意味的に繋がっている文章を1行にまとめる                      │
│    - 例: 「肥満気味\nな方へ」→「肥満気味な方へ」                               │
│    - 例: 「体脂肪\n体重の減少を\n本気で\nサポート!」                           │
│          →「体脂肪 体重の減少を本気でサポート!」                               │
│    - 例: 「1,000円\nOFF」→「1,000円OFF」                                     │
│                                                                             │
│ 2. **段落の区切り**: 異なるセクション・話題の間は空行で区切る                   │
│    - 見出しと本文の間                                                        │
│    - 異なる商品情報の間                                                       │
│    - 注釈と本文の間                                                          │
│                                                                             │
│ 3. **誤字修正**: OCRの明らかな誤認識のみ修正                                   │
│                                                                             │
│ ## 出力形式:                                                                 │
│ - プレーンテキストで出力                                                      │
│ - 1つの文章・フレーズは1行にまとめる                                          │
│ - セクション間は空行で区切る                                                  │
│ - 全てのテキストを漏れなく出力（削除禁止）                                      │
│                                                                             │
│ ## 入力テキスト:                                                              │
│ ${rawText}                                                                  │
│                                                                             │
│ ## 整形後のテキスト:                                                          │
│                                                                             │
│ ═══════════════════════════════════════════════════════════════════════════ │
│                                                                             │
│ エラーハンドリング:                                                          │
│ - 後処理に失敗した場合は、前処理済みテキストをそのまま返す                       │
│                                                                             │
│ 出力: string (整形済み最終テキスト)                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 18: 完了 [progress: 100%]                                               │
│                                                                             │
│ ジョブステータス更新:                                                         │
│ {                                                                           │
│   status: 'completed',                                                      │
│   progress: 100,                                                            │
│   ocrText: <最終テキスト>                                                    │
│ }                                                                           │
│                                                                             │
│ クリーンアップ:                                                              │
│ - 1時間後にジョブステータスをメモリから削除                                     │
│ - 画像はCloud Storageのライフサイクルポリシーで管理                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. API詳細仕様

### 3.1 POST /api/capture

キャプチャジョブを開始する。

**リクエスト**
```http
POST /api/capture
Content-Type: application/json

{
  "url": "https://example.com/landing-page"
}
```

**レスポンス（即座に返却）**
```json
{
  "jobId": "m1abc123xyz"
}
```

**jobId生成ロジック**
```typescript
const jobId = Date.now().toString(36) + Math.random().toString(36).slice(2);
// 例: "m1abc123" + "xyz789def" = "m1abc123xyz789def"
```

---

### 3.2 GET /api/status/:jobId

ジョブの進行状況を取得する（ポーリング用）。

**レスポンス例**
```json
{
  "status": "ocr_processing",
  "progress": 75,
  "ocrChunks": {
    "current": 3,
    "total": 4
  }
}
```

**ステータス遷移表**

| status | progress | 説明 | 次のステータス |
|--------|----------|------|---------------|
| starting | 0 | ジョブ開始 | launching |
| launching | 5 | ブラウザ起動中 | loading |
| loading | 10 | ページ読み込み中 | capturing |
| capturing | 10-50 | セグメントキャプチャ中 | compositing |
| compositing | 50 | 画像合成中 | ocr_starting |
| ocr_starting | 55 | OCR開始 | ocr_processing |
| ocr_processing | 55-85 | テキスト抽出中 | ocr_cleaning |
| ocr_cleaning | 90 | 改行整形中 | completed |
| completed | 100 | 完了 | - |
| error | 0 | エラー発生 | - |

**progress計算式**

```typescript
// capturing中
progress = Math.round(((currentSegment + 1) / totalSegments) * 40) + 10;
// 例: 5セグメント中3セグメント目 → (3/5)*40 + 10 = 34%

// ocr_processing中
progress = Math.round((currentChunk / totalChunks) * 30) + 55;
// 例: 4チャンク中3チャンク目 → (3/4)*30 + 55 = 77.5% → 78%
```

---

### 3.3 GET /api/download/:jobId

キャプチャ画像をダウンロードする。

**レスポンス**
```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Disposition: attachment; filename=capture-m1abc123xyz.jpg

<JPEG画像バイナリ>
```

**Cloud Storageからの取得ロジック**
```typescript
// 1. まずJPGを探す（新形式）
const jpgFile = bucket.file(`${jobId}.jpg`);
if (await jpgFile.exists()) return jpgFile;

// 2. なければPNGを探す（旧形式の互換性）
const pngFile = bucket.file(`${jobId}.png`);
if (await pngFile.exists()) return pngFile;

// 3. どちらもなければ404
return null;
```

---

### 3.4 GET /api/preview/:jobId

サムネイル画像を取得する。

**処理**
```typescript
const thumbnail = await sharp(buffer)
  .resize(400, undefined, { fit: 'inside' })
  .png()
  .toBuffer();
```

**レスポンス**
```http
HTTP/1.1 200 OK
Content-Type: image/png

<PNGサムネイルバイナリ>
```

---

### 3.5 GET /api/ocr/:jobId

OCRテキストを取得する。

**レスポンス**
```json
{
  "text": "抽出されたテキスト...\n\n段落区切り...\n\n次のセクション..."
}
```

---

## 4. エラーハンドリング

### 4.1 キャプチャ段階のエラー

| エラー | 原因 | 対応 |
|--------|------|------|
| タイムアウト | ページが120秒以内に読み込めない | error ステータスで終了 |
| ブラウザ起動失敗 | メモリ不足等 | error ステータスで終了 |
| ナビゲーション失敗 | URL無効、サーバーダウン | error ステータスで終了 |

### 4.2 OCR段階のエラー

| エラー | 原因 | 対応 |
|--------|------|------|
| RESOURCE_EXHAUSTED | APIクォータ超過 | 専用エラーメッセージで終了 |
| 503/overloaded/UNAVAILABLE | API過負荷 | 最大3回リトライ |
| 429 | レートリミット | 最大3回リトライ（遅延増加） |
| too large | 画像サイズ超過 | 専用エラーメッセージで終了 |

### 4.3 リトライ機構詳細

```typescript
async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delayMs: number = 2000
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      const isRetryable =
        error.message.includes('503') ||
        error.message.includes('overloaded') ||
        error.message.includes('UNAVAILABLE') ||
        error.message.includes('429');

      if (!isRetryable || i === maxRetries - 1) {
        throw error;
      }

      // 遅延: 2秒, 4秒, 6秒（線形増加）
      await sleep(delayMs * (i + 1));
    }
  }
}
```

---

## 5. 制限事項

### 5.1 技術的制限

| 項目 | 制限値 | 理由 | 対策 |
|------|--------|------|------|
| 画像最大高さ | 16000px | JPEG形式の制限 | 超過時は自動リサイズ |
| レスポンスサイズ | 32MB | Cloud Run制限 | JPEG圧縮で対応 |
| ページ読み込み | 120秒 | タイムアウト設定 | エラー終了 |
| OCRチャンク | 4000px | API制限対策 | 自動分割 |
| ジョブ保持 | 1時間 | メモリ管理 | 自動削除 |

### 5.2 キャプチャ不可コンテンツ

| コンテンツ | 理由 | 回避策 |
|------------|------|--------|
| ログイン必須ページ | 認証が必要 | なし |
| CAPTCHAページ | 自動化検出 | なし |
| iframe内コンテンツ | クロスオリジン制限 | なし |
| Flash/Silverlight | 非対応形式 | なし |
| PDF埋め込み | レンダリング不可 | なし |

### 5.3 OCRの限界

| ケース | 対応状況 | 備考 |
|--------|----------|------|
| 手書き文字 | △ 精度低下 | 印刷体推奨 |
| 極小文字（8px以下） | △ 読み取り困難 | |
| 複雑な表組み | △ 構造崩れ可能性 | シンプルな表は可 |
| 縦書きテキスト | △ 部分サポート | 横書き推奨 |
| 装飾文字・アート文字 | △ 精度低下 | |
| 低コントラスト文字 | △ 精度低下 | |

---

## 6. 環境変数

| 変数名 | 必須 | デフォルト | 説明 |
|--------|------|------------|------|
| GEMINI_API_KEY | ○ | - | Gemini API キー |
| GEMINI_OCR_MODEL | - | gemini-2.0-flash | OCRに使用するモデル |
| PORT | - | 3100 | サーバーポート |
| GOOGLE_APPLICATION_CREDENTIALS | ○ | - | GCPサービスアカウントキーのパス |

---

## 7. ファイル構成

```
site-transcription/
├── server.ts              # メインサーバー（Express + キャプチャロジック）
├── gemini-helper.ts       # OCR処理（Gemini API呼び出し）
├── package.json           # 依存関係定義
├── Dockerfile             # Cloud Run用コンテナ定義
├── .env                   # 環境変数（ローカル用）
├── public/
│   └── index.html         # フロントエンドUI
└── SPECIFICATION_DETAILED.md  # この仕様書
```

---

## 8. 処理時間の目安

| ページタイプ | 高さ | キャプチャ | OCR | 合計 |
|--------------|------|-----------|-----|------|
| 短いLP | ~3000px | 10-15秒 | 5-10秒 | 15-25秒 |
| 標準LP | ~10000px | 20-30秒 | 15-25秒 | 35-55秒 |
| 長いLP | ~20000px | 40-60秒 | 30-45秒 | 70-105秒 |
| 超長いLP | ~40000px | 80-120秒 | 60-90秒 | 140-210秒 |

※ネットワーク状況、API負荷状況により変動

---

**最終更新**: 2026-01-22
**バージョン**: 2.0.0
